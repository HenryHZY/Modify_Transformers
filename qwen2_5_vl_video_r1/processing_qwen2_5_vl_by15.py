#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨
#           This file was automatically generated from src/transformers/models/qwen2_5_vl/modular_qwen2_5_vl.py.
#               Do NOT edit this file manually as any edits will be overwritten by the generation of
#             the file from the modular. If any change should be done, please apply the change to the
#                          modular_qwen2_5_vl.py file directly. One of our CI enforces this.
#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨
# coding=utf-8
# Copyright 2025 The Qwen Team and The HuggingFace Inc. team. All rights reserved.
#
# This code is based on EleutherAI's GPT-NeoX library and the GPT-NeoX
# and OPT implementations in this library. It has been modified from its
# original forms to accommodate minor architectural differences compared
# to GPT-NeoX and OPT used by the Meta AI team that trained the model.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
from typing import List, Union
import torch

from ...feature_extraction_utils import BatchFeature
from ...image_utils import ImageInput, VideoInput
from ...processing_utils import ProcessingKwargs, ProcessorMixin, Unpack, VideosKwargs
from ...tokenization_utils_base import PreTokenizedInput, TextInput


class Qwen2_5_VLVideosProcessorKwargs(VideosKwargs, total=False):
    fps: Union[List[float], float]


class Qwen2_5_VLProcessorKwargs(ProcessingKwargs, total=False):
    videos_kwargs: Qwen2_5_VLVideosProcessorKwargs
    _defaults = {
        "text_kwargs": {
            "padding": False,
        },
        "videos_kwargs": {"fps": 2.0},
    }


class Qwen2_5_VLProcessor(ProcessorMixin):
    r"""
    Constructs a Qwen2.5-VL processor which wraps a Qwen2.5-VL image processor and a Qwen2 tokenizer into a single processor.
    [`Qwen2_5_VLProcessor`] offers all the functionalities of [`Qwen2_5_VLImageProcessor`] and [`Qwen2TokenizerFast`]. See the
    [`~Qwen2_5_VLProcessor.__call__`] and [`~Qwen2_5_VLProcessor.decode`] for more information.
    Args:
        image_processor ([`Qwen2_5_VLImageProcessor`], *optional*):
            The image processor is a required input.
        tokenizer ([`Qwen2TokenizerFast`], *optional*):
            The tokenizer is a required input.
        chat_template (`str`, *optional*): A Jinja template which will be used to convert lists of messages
            in a chat into a tokenizable string.
    """

    attributes = ["image_processor", "tokenizer"]
    valid_kwargs = ["chat_template"]

    image_processor_class = "Qwen2_5_VLImageProcessor"
    tokenizer_class = ("Qwen2Tokenizer", "Qwen2TokenizerFast")

    def __init__(self, image_processor=None, tokenizer=None, chat_template=None, **kwargs):
        self.image_token = "<|image_pad|>" if not hasattr(tokenizer, "image_token") else tokenizer.image_token
        self.video_token = "<|video_pad|>" if not hasattr(tokenizer, "video_token") else tokenizer.video_token
        super().__init__(image_processor, tokenizer, chat_template=chat_template)

    def __call__(
        self,
        images: ImageInput = None,
        text: Union[TextInput, PreTokenizedInput, List[TextInput], List[PreTokenizedInput]] = None,
        videos: VideoInput = None,
        **kwargs: Unpack[Qwen2_5_VLProcessorKwargs],
    ) -> BatchFeature:
        """
        Main method to prepare for the model one or several sequences(s) and image(s). This method forwards the `text`
        and `kwargs` arguments to Qwen2TokenizerFast's [`~Qwen2TokenizerFast.__call__`] if `text` is not `None` to encode
        the text. To prepare the vision inputs, this method forwards the `vision_infos` and `kwrags` arguments to
        Qwen2_5_VLImageProcessor's [`~Qwen2_5_VLImageProcessor.__call__`] if `vision_infos` is not `None`.

        Args:
            images (`PIL.Image.Image`, `np.ndarray`, `torch.Tensor`, `List[PIL.Image.Image]`, `List[np.ndarray]`, `List[torch.Tensor]`):
                The image or batch of images to be prepared. Each image can be a PIL image, NumPy array or PyTorch
                tensor. Both channels-first and channels-last formats are supported.
            text (`str`, `List[str]`, `List[List[str]]`):
                The sequence or batch of sequences to be encoded. Each sequence can be a string or a list of strings
                (pretokenized string). If the sequences are provided as list of strings (pretokenized), you must set
                `is_split_into_words=True` (to lift the ambiguity with a batch of sequences).
            videos (`np.ndarray`, `torch.Tensor`, `List[np.ndarray]`, `List[torch.Tensor]`):
                The image or batch of videos to be prepared. Each video can be a 4D NumPy array or PyTorch
                tensor, or a nested list of 3D frames. Both channels-first and channels-last formats are supported.
            return_tensors (`str` or [`~utils.TensorType`], *optional*):
                If set, will return tensors of a particular framework. Acceptable values are:
                - `'tf'`: Return TensorFlow `tf.constant` objects.
                - `'pt'`: Return PyTorch `torch.Tensor` objects.
                - `'np'`: Return NumPy `np.ndarray` objects.
                - `'jax'`: Return JAX `jnp.ndarray` objects.

        Returns:
            [`BatchFeature`]: A [`BatchFeature`] with the following fields:

            - **input_ids** -- List of token ids to be fed to a model. Returned when `text` is not `None`.
            - **attention_mask** -- List of indices specifying which tokens should be attended to by the model (when
              `return_attention_mask=True` or if *"attention_mask"* is in `self.model_input_names` and if `text` is not
              `None`).
            - **pixel_values** -- Pixel values to be fed to a model. Returned when `images` is not `None`.
            - **pixel_values_videos** -- Pixel values of videos to be fed to a model. Returned when `videos` is not `None`.
            - **image_grid_thw** -- List of image 3D grid in LLM. Returned when `images` is not `None`.
            - **video_grid_thw** -- List of video 3D grid in LLM. Returned when `videos` is not `None`.
            - **second_per_grid_ts** -- List of video seconds per time grid. Returned when `videos` is not `None`.
        """

        output_kwargs = self._merge_kwargs(
            Qwen2_5_VLProcessorKwargs,
            tokenizer_init_kwargs=self.tokenizer.init_kwargs,
            **kwargs,
        )
        if images is not None:
            image_inputs = self.image_processor(images=images, videos=None, **output_kwargs["images_kwargs"])
            image_grid_thw = image_inputs["image_grid_thw"]
        else:
            image_inputs = {}
            image_grid_thw = None

        if videos is not None:
            videos_inputs = self.image_processor(images=None, videos=videos, **output_kwargs["images_kwargs"])
            video_grid_thw = videos_inputs["video_grid_thw"]

            fps = output_kwargs["videos_kwargs"].pop("fps", 2.0)
            if isinstance(fps, (int, float)):
                second_per_grid_ts = [self.image_processor.temporal_patch_size / fps] * len(video_grid_thw)
            elif hasattr(fps, "__len__") and len(fps) == len(video_grid_thw):
                second_per_grid_ts = [self.image_processor.temporal_patch_size / tmp for tmp in fps]
            else:
                raise ValueError(
                    f"The length of fps ({len(fps) if hasattr(fps, '__len__') else fps}) must be equal to the length of video_grid_thw ({len(video_grid_thw)}) or fps should be a single number."
                )
            videos_inputs.update({"second_per_grid_ts": second_per_grid_ts})

        else:
            videos_inputs = {}
            video_grid_thw = None

        if not isinstance(text, list):
            text = [text]

        if image_grid_thw is not None:
            merge_length = self.image_processor.merge_size**2
            index = 0
            for i in range(len(text)):
                while self.image_token in text[i]:
                    text[i] = text[i].replace(
                        self.image_token,
                        "<|placeholder|>" * (image_grid_thw[index].prod() // merge_length),
                        1,
                    )
                    index += 1
                text[i] = text[i].replace("<|placeholder|>", self.image_token)

        if video_grid_thw is not None:
            merge_length = self.image_processor.merge_size**2
            index = 0
            for i in range(len(text)):
                while self.video_token in text[i]:
                    text[i] = text[i].replace(
                        self.video_token,
                        "<|placeholder|>" * (video_grid_thw[index].prod() // merge_length),
                        1,
                    )
                    index += 1
                text[i] = text[i].replace("<|placeholder|>", self.video_token)

        text_inputs = self.tokenizer(text, **output_kwargs["text_kwargs"])
        # import pdb; pdb.set_trace()
        ############# Token Merging Preparation #############
        run_our_forward = True
        if run_our_forward:
            # variables to be updated
            input_ids = text_inputs['input_ids'] # (B, L)
            attention_mask = text_inputs['attention_mask'] # (B, L)
            pad_token_id = self.tokenizer.convert_tokens_to_ids(self.tokenizer.pad_token)
            image_token_id = self.tokenizer.convert_tokens_to_ids('<|image_pad|>')
            video_token_id = self.tokenizer.convert_tokens_to_ids('<|video_pad|>')
            
            # perform sample wise operation to support batch inference
            all_updated_input_ids = []
            all_updated_attention_masks = []
            all_updated_boundaries = []
            for b in range(input_ids.size(0)):
                input_ids_b = input_ids[b:b+1] # (1, L)
                attention_mask_b = attention_mask[b:b+1] # (1, L)

                # original variables (per sample)
                if 'image_grid_thw' in image_inputs:
                    vis_grid_thw_b = image_inputs['image_grid_thw'][b]
                    v_pos_mask = input_ids_b == image_token_id
                elif 'video_grid_thw' in videos_inputs:
                    vis_grid_thw_b = videos_inputs['video_grid_thw'][b]
                    v_pos_mask = input_ids_b == video_token_id
                else:
                    vis_grid_thw_b = None
                    v_pos_mask = None

                if v_pos_mask is not None:
                    # original boundary
                    first_nonzero_idx = v_pos_mask.float().argmax(dim=1) # (1,)
                    v_start_idx = first_nonzero_idx.view(1,-1)
                    n_vis_tokens = (v_pos_mask).sum().item()
                    q_start_idx = v_start_idx + n_vis_tokens
                    end_idx_plus = q_start_idx.new_full(q_start_idx.shape, fill_value=input_ids_b[b:b+1].size(1))
                    boundaries = torch.cat((v_start_idx, q_start_idx, end_idx_plus), dim=1) # (1, 3), [visual token start idx, question token start idx, #tokens] (system promt - visual - question)

                    # visual variables
                    T = vis_grid_thw_b[0].item()
                    H = vis_grid_thw_b[1].item() // self.image_processor.merge_size # self.config.vision_config.spatial_merge_size # see Qwen2_5_VLPatchMerger
                    W = vis_grid_thw_b[2].item() // self.image_processor.merge_size # self.config.vision_config.spatial_merge_size # see Qwen2_5_VLPatchMerger
                    token_cnt = H * W
                    token_cnt = token_cnt - token_cnt // 2 # 50%
                    # token_cnt = token_cnt - token_cnt // 2 # 25%
                    # token_cnt = min(token_cnt, (H // 2) * (W // 2)) # re-assign position ids
                    reduct_cnt = int(H * W - token_cnt) * T # int(H * W - token_cnt) * T # int(H * W * 0.01) * T # 
                    
                    # split input_ids
                    input_ids_sys = input_ids_b[:, :boundaries[0, 0].item()]
                    input_ids_vis = input_ids_b[:, boundaries[0, 0].item():boundaries[0, 1].item()][:, reduct_cnt:]
                    input_ids_q   = input_ids_b[:, boundaries[0, 1].item():]
                    updated_input_ids_b = torch.cat((input_ids_sys, input_ids_vis, input_ids_q), dim=-1)
                    # updated_input_ids_b = torch.cat((input_ids_sys, input_ids_q), dim=-1) # visual ids will be injected according to needs

                    # split attention_mask
                    attention_mask_sys = attention_mask_b[:, :boundaries[0, 0].item()]
                    attention_mask_vis = attention_mask_b[:, boundaries[0, 0].item():boundaries[0, 1].item()][:, reduct_cnt:]
                    attention_mask_q   = attention_mask_b[:, boundaries[0, 1].item():]
                    updated_attention_mask_b = torch.cat((attention_mask_sys, attention_mask_vis, attention_mask_q), dim=-1) # attention_mask[:, :updated_input_ids.size(1)]
                    # updated_attention_mask_b = torch.cat((attention_mask_sys, attention_mask_q), dim=-1) # visual ids will be injected according to needs

                    # new boundary
                    boundaries = torch.cat((v_start_idx, q_start_idx - reduct_cnt, end_idx_plus - reduct_cnt), dim=1) # shadow input_ids
                    # boundaries = torch.cat((v_start_idx, v_start_idx, end_idx_plus - n_vis_tokens), dim=1) # visual ids will be injected according to needs
                else:
                    # no visual tokens, leave unchanged
                    updated_input_ids_b = input_ids_b
                    updated_attention_mask_b = attention_mask_b
                all_updated_input_ids.append(updated_input_ids_b)
                all_updated_attention_masks.append(updated_attention_mask_b)
                all_updated_boundaries.append(boundaries)

            # find max length among all sequences
            max_len = max(x.size(1) for x in all_updated_input_ids)
            # left pad input_ids
            padded_input_ids = []
            for ids in all_updated_input_ids:
                pad_len = max_len - ids.size(1)
                padded = torch.cat([torch.full((1,pad_len), pad_token_id, dtype=ids.dtype, device=ids.device), ids], dim=1) # left pad
                padded_input_ids.append(padded)
            text_inputs['input_ids'] = torch.cat(padded_input_ids, dim=0)
            # left pad attention_mask
            padded_attention_masks = []
            for mask in all_updated_attention_masks:
                pad_len = max_len - mask.size(1)
                padded = torch.cat([torch.zeros((1,pad_len), dtype=mask.dtype, device=mask.device), mask], dim=1) # left pad
                padded_attention_masks.append(padded)
            text_inputs['attention_mask'] = torch.cat(padded_attention_masks, dim=0)
            # adjust boundaries
            adjusted_boundaries = torch.zeros((input_ids.size(0), 3), dtype=boundaries.dtype, device=boundaries.device)
            for b_i, ids in enumerate(all_updated_input_ids):
                pad_len = max_len - ids.size(1)
                adjusted_boundaries[b_i, 0] = all_updated_boundaries[b_i][0, 0] + pad_len # instruction token move right due to padding
                adjusted_boundaries[b_i, 1] = all_updated_boundaries[b_i][0, 1] + pad_len # question tokens move right (padding)
                adjusted_boundaries[b_i, 2] = all_updated_boundaries[b_i][0, 2] + pad_len # end+1 token move right (padding)
            text_inputs['preprocess_boundaries'] = adjusted_boundaries
        else:
            text_inputs['preprocess_boundaries'] = None
        ############# Token Merging Preparation #############
        return BatchFeature(data={**text_inputs, **image_inputs, **videos_inputs})

    def batch_decode(self, *args, **kwargs):
        """
        This method forwards all its arguments to Qwen2TokenizerFast's [`~PreTrainedTokenizer.batch_decode`]. Please
        refer to the docstring of this method for more information.
        """
        return self.tokenizer.batch_decode(*args, **kwargs)

    def decode(self, *args, **kwargs):
        """
        This method forwards all its arguments to Qwen2TokenizerFast's [`~PreTrainedTokenizer.decode`]. Please refer to
        the docstring of this method for more information.
        """
        return self.tokenizer.decode(*args, **kwargs)

    def post_process_image_text_to_text(self, generated_outputs):
        """
        Post-process the output of the model to decode the text.

        Args:
            generated_outputs (`torch.Tensor` or `np.ndarray`):
                The output of the model `generate` function. The output is expected to be a tensor of shape `(batch_size, sequence_length)`
                or `(sequence_length,)`.

        Returns:
            `List[str]`: The decoded text.
        """
        return self.tokenizer.batch_decode(
            generated_outputs, skip_special_tokens=True, clean_up_tokenization_spaces=False
        )

    @property
    def model_input_names(self):
        tokenizer_input_names = self.tokenizer.model_input_names
        image_processor_input_names = self.image_processor.model_input_names
        return list(dict.fromkeys(tokenizer_input_names + image_processor_input_names))


__all__ = ["Qwen2_5_VLProcessor"]
